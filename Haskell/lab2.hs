-- ⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⡜⠘⠀⠀⠀⠀⠈⣿⠀⠁⣿⢳⠁⢈⢰⡦⠈⠀⢻
-- ⣿⣿⡏⠀⠀⢀⣀⠀⠀⡀⠀⠀⢀⠀⠀⠁⠀⠀⠈⠉⠀⠀⠀⡘⠀⢰⠛⢠⣴⣄⣌
-- ⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⢠⣠⡀⠀⠀⠀⠂⠀⠀⠀⠐⠀⠈⣡⠻⢹⢿
-- ⣿⣿⠀⠀⠀⠁⠀⠀⠀⠄⠀⠀⡀⣀⣼⣟⣿⢵⣤⣤⣤⣤⣤⣤⣄⣀⣀⣠⠀⠢⣽
-- ⣿⡿⠀⠀⠀⠀⠀⢐⣌⢖⣰⠊⠁⢸⣿⡟⠈⠀⢾⣿⣿⣿⣿⣿⣿⣿⣿⣾⡄⢰⢺
-- ⣿⡇⠀⠀⠀⠀⢀⡀⢴⢖⣠⣣⣴⣿⢿⡇⣈⠐⢺⣿⣿⣿⣿⣿⣿⣿⣿⣿⡀⢠⣸
-- ⣿⣷⡀⠀⠀⠀⠀⠸⣼⣿⣿⣿⣿⡷⠋⠅⠀⡀⢼⣿⠯⣿⣿⣿⣿⣿⣿⣿⡇⣼⣿
-- ⡿⠁⠸⣄⣦⡀⠀⢡⣿⣿⣿⣿⣏⡤⠄⠄⠀⠀⠈⠉⠁⠘⢿⣿⣿⣿⣿⣿⣯⢸⣿
-- ⠇⠀⠀⡹⢿⡏⠀⣾⣿⣟⠋⠉⠁⠀⠀⠀⠀⣀⣀⠀⠀⠀⢸⣿⠎⠉⠉⠉⠛⣤⣿
-- ⡆⠀⡀⢣⢈⡟⠠⠻⣿⣿⣷⡄⠀⠀⢸⣶⣷⣷⣧⡄⠀⠀⢿⣧⢀⡀⠀⠉⢡⣿⣿
-- ⣿⣦⡀⠘⢼⠃⣠⡲⠛⢿⡿⣿⡀⡀⠀⠹⣿⣿⡟⠀⠠⣤⠘⣿⣶⣿⣶⡾⣳⣿⣿
-- ⣿⡿⣿⣶⡌⠰⡅⠌⠠⠈⠈⠙⢙⠑⢰⠀⠨⠟⠀⠀⣴⢌⡅⢻⣿⣿⣿⡇⣿⣿⣿
-- ⣿⢇⣿⣿⠣⢿⣮⠀⢀⡀⠀⠀⠈⠁⣶⠀⠀⠀⠀⠀⠁⠀⢡⣺⣿⣿⡿⣸⣿⣿⣿
-- ⣿⣾⣿⣏⠐⣿⢟⡈⠂⠀⠠⠀⠀⠀⣆⠀⠀⠀⠀⠀⠀⣢⣼⣸⣿⡿⢈⣿⣿⣿⣿
-- ⣿⣿⣿⠃⡀⠈⠑⠁⠀⠄⠀⠀⠀⠲⠀⠀⠄⣀⠀⣸⣷⣮⣍⠃⢹⠇⣿⣿⣿⣿⣿
-- ⣿⣿⣿⢀⣾⣷⣶⣌⠀⠠⠀⠀⢀⠍⠀⠀⠀⠀⠉⠁⠈⠙⠋⢰⡝⣼⣿⣿⣿⣿⣿
-- ⣿⣿⣿⠋⠀⣼⣿⣿⣷⣄⠀⠀⠀⠊⠀⠀⠀⠀⠀⠀⠄⡀⢀⣼⢣⣿⣿⣿⣿⣿⣿
-- ⣿⣿⣯⠀⢸⣿⣿⣿⡟⠛⠳⣄⠀⠀⠀⠀⠘⠌⠓⡀⢰⣮⣾⢠⣿⣿⣿⣿⣿⣿⣿
-- ⣿⣿⣧⠀⣹⣿⣿⣿⠗⠀⠀⠀⠀⠀⣀⡀⠀⠈⠀⠀⠈⠝⣡⣾⣿⣿⣿⣿⣿⣿⣿
-- ⣿⣿⡏⠀⣿⣿⣿⠿⠃⢀⣴⣶⣾⣿⣿⣿⣿⣷⣾⢠⣶⣾⣮⣙⡻⣿⢿⣿⣿⣿⣿
-- ⣿⣿⡇⠀⣿⣿⠃⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⡟⡼⠿⣿⣿⣿⣿⣮⡑⡝⣿⣿⣿
--1)
--a)
data Carrera = Matematica | Fisica | Computacion | Astronomia deriving (Eq, Ord, Bounded, Show)
--b)
titulo :: Carrera -> String 
titulo Matematica = "Licenciatura de Matematica" 
titulo Astronomia = "Licenciatura de Astronomia" 
titulo Computacion = "Licenciatura de Computacion" 
titulo Fisica = "Licenciatura de Fisica" 
--c)
data NotaBasica = Do | Re | Mi | Fa | Sol | La | Si deriving (Eq, Ord, Bounded, Show)
--d)
cifradoAmericano :: NotaBasica -> Char
cifradoAmericano Do = 'C'
cifradoAmericano Re = 'D'
cifradoAmericano Mi = 'E'
cifradoAmericano Fa = 'F'
cifradoAmericano Sol = 'G'
cifradoAmericano La = 'A'
cifradoAmericano Si = 'B'

--3
--a) 
minimoElemento :: Ord a => [a] -> a 
minimoElemento [x] = x 
minimoElemento (x:xs) = x `min` (minimoElemento xs) 

--b) dudas con este 
minimoElemento' :: (Ord a, Bounded a) => [a] -> a 
minimoElemento' [] = minBound
minimoElemento' [x] = x
minimoElemento' (x:xs) = x `min` (minimoElemento' xs)
--c) minimoElemento [Fa, La, Sol, Re, Fa] = Re

--4)
--a) 
type Ingreso = Int 
data Cargo = Titular | Asociado | Adjunto | Asistente | Auxiliar deriving (Eq, Ord, Bounded, Show)

data Area = Administrativa | Ensenanza | Economica | Postgrado deriving (Eq, Ord, Bounded, Show)

data Persona = Decane | Docente Cargo | NoDocente Area | Estudiante Carrera Ingreso deriving (Eq, Ord, Show) 

--b) Docente :: Cargo -> Persona 
--c) 
cuantos_doc :: [Persona] -> Cargo -> Int 
cuantos_doc [] c = 0
cuantos_doc (x:xs) c = length (filter (Docente c==) xs)

--5)
--a) 
data Alteracion = Bemol | Sostenido | Natural deriving (Eq, Ord)
data NotaMusical = Nota NotaBasica Alteracion deriving (Eq, Ord)

sonido :: NotaBasica -> Int
sonido Do = 1
sonido Re = 3
sonido Mi = 5
sonido Fa = 6
sonido Sol = 8
sonido La = 10
sonido Si = 12

--b) 
sonidoCromatico :: NotaMusical -> Int 
sonidoCromatico (Nota x y) | y == Bemol = sonido x - 1 
    | y == Sostenido = sonido x + 1 
    | y == Natural = sonido x

--6) 
--a) 
primerElemento :: [a] -> Maybe a 
primerElemento [] = Nothing 
primerElemento xs = Just (head xs) 

--7) 
data Cola = VaciaC | Encolada Persona Cola deriving Show

--a) 
--1) 
atender :: Cola -> Maybe Cola 
atender (Encolada p VaciaC) = Nothing 
atender (Encolada p c) = Just c
--2) 
encolar :: Persona -> Cola -> Cola 
encolar p (Encolada p' c) = (Encolada p' (Encolada p VaciaC))
--3) 
busca :: Cola -> Cargo -> Maybe Persona 
busca VaciaC c = Nothing 
busca (Encolada (Docente x) z) c |  c == x = Just (Docente x)  
    | c /= x = busca z c 

--8) 
--a) 
type Diccionario = ListaAsoc String String
type Padron = ListaAsoc Int String
type GuiaTelefonica = ListaAsoc String Int

data ListaAsoc a b = Vacia | Nodo a b (ListaAsoc a b) deriving (Eq, Ord, Show) 

--b) 
--1) 
la_long :: ListaAsoc a b -> Int 
la_long Vacia = 0
la_long (Nodo x y (z)) = 1 + la_long z 

--2)
la_concat :: ListaAsoc a b -> ListaAsoc a b -> ListaAsoc a b 
la_concat (Nodo x y z) Vacia = (Nodo x y Vacia)
la_concat Vacia (Nodo x' y' z') = (Nodo x' y' Vacia)
la_concat (Nodo x y z) (Nodo x' y' z') = (Nodo x y (Nodo x' y' Vacia))

--3) 
la_agregar :: ListaAsoc a b -> a -> b -> ListaAsoc a b 
la_agregar Vacia x' y' = (Nodo x' y' Vacia)  
la_agregar (Nodo x y z)  x' y' = (Nodo x y (Nodo x' y' Vacia))

--4) 
la_pares :: ListaAsoc a b -> [(a, b)]
la_pares Vacia = []
la_pares (Nodo x y z) = (x, y) : la_pares z  

la_busca :: Eq a => ListaAsoc a b -> a -> Maybe b 
la_busca Vacia c = Nothing 
la_busca (Nodo x y z) c | x == c = Just y 
    | x /= c = la_busca z c 

--6) 
la_borrar :: Eq a => a -> ListaAsoc a b -> ListaAsoc a b 
la_borrar c Vacia = Vacia 
la_borrar c (Nodo x y z) | x == c = la_borrar c z
    | x /= c = (Nodo x y (la_borrar  c z))

--9) 
data Arbol a = Hoja | Rama (Arbol a) a (Arbol a) deriving (Eq, Ord, Show)

type Prefijos = Arbol String
can , cana , canario , canas , cant , cantar , canto :: Prefijos
can = Rama cana "can" cant
cana = Rama canario "a" canas
canario = Rama Hoja "rio" Hoja
canas = Rama Hoja  "s" Hoja
cant = Rama cantar "t" canto
cantar = Rama Hoja "ar" Hoja
canto = Rama Hoja "o" Hoja

type Numeros = Arbol Int 
uno , dos , tres , cuatro , cinco , seis , siete :: Numeros 
uno = Rama dos 1 tres 
dos = Rama cuatro 2 cinco 
cuatro = Rama Hoja 4 Hoja 
cinco = Rama Hoja 5 Hoja 
tres = Rama seis 3 siete 
seis = Rama Hoja 6 Hoja 
siete = Rama Hoja 7 Hoja  

--a)
a_long :: Arbol a -> Int 
a_long Hoja = 0
a_long (Rama x y z) = 1 + a_long x + a_long z 

--b) no entiendo el numero de hojas, pero capaz es todo dividido 
a_hojas :: Arbol a -> Int 
a_hojas Hoja = 1
a_hojas (Rama x y z) = 0 + a_hojas x + a_hojas z 

--c) 
a_inc :: Num a => Arbol a -> Arbol a 
a_inc Hoja = Hoja
a_inc (Rama x y z) = (Rama (a_inc x) (y+1) (a_inc z))  

--d) 
a_map :: (a -> b) -> Arbol a -> Arbol b 
a_map f Hoja = Hoja 
a_map f (Rama x y z) = (Rama (a_map f x) (f y) (a_map f z))

a_inc' (Rama x y z) = a_map (+1) (Rama x y z)

-- ⣿⣿⣿⣿⣯⣿⣿⠄⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠈⣿⣿⣿⣿⣿⣿⣆⠄
-- ⢻⣿⣿⣿⣾⣿⢿⣢⣞⣿⣿⣿⣿⣷⣶⣿⣯⣟⣿⢿⡇⢃⢻⣿⣿⣿⣿⣿⢿⡄
-- ⠄⢿⣿⣯⣏⣿⣿⣿⡟⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣧⣾⢿⣮⣿⣿⣿⣿⣾⣷
-- ⠄⣈⣽⢾⣿⣿⣿⣟⣄⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣝⣯⢿⣿⣿⣿⣿
-- ⣿⠟⣫⢸⣿⢿⣿⣾⣿⢿⣿⣿⢻⣿⣿⣿⢿⣿⣿⣿⢸⣿⣼⣿⣿⣿⣿⣿⣿⣿
-- ⡟⢸⣟⢸⣿⠸⣷⣝⢻⠘⣿⣿⢸⢿⣿⣿⠄⣿⣿⣿⡆⢿⣿⣼⣿⣿⣿⣿⢹⣿
-- ⡇⣿⡿⣿⣿⢟⠛⠛⠿⡢⢻⣿⣾⣞⣿⡏⠖⢸⣿⢣⣷⡸⣇⣿⣿⣿⢼⡿⣿⣿
-- ⣡⢿⡷⣿⣿⣾⣿⣷⣶⣮⣄⣿⣏⣸⣻⣃⠭⠄⠛⠙⠛⠳⠋⣿⣿⣇⠙⣿⢸⣿
-- ⠫⣿⣧⣿⣿⣿⣿⣿⣿⣿⣿⣿⠻⣿⣾⣿⣿⣿⣿⣿⣿⣿⣷⣿⣿⣹⢷⣿⡼⠋
-- ⠄⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⣿⣿⣿⠄⠄
-- ⠄⠄⢻⢹⣿⠸⣿⣿⣿⣿⣿⣷⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⣼⣿⣿⣿⣿⡟⠄⠄
-- ⠄⠄⠈⢸⣿⠄⠙⢿⣿⣿⣹⣿⣿⣿⣿⣟⡃⣽⣿⣿⡟⠁⣿⣿⢻⣿⣿⢿⠄⠄
-- ⠄⠄⠄⠘⣿⡄⠄⠄⠙⢿⣿⣿⣾⣿⣷⣿⣿⣿⠟⠁⠄⠄⣿⣿⣾⣿⡟⣿⠄⠄
-- ⠄⠄⠄⠄⢻⡇⠸⣆⠄⠄⠈⠻⣿⡿⠿⠛⠉⠄⠄⠄⠄⢸⣿⣇⣿⣿⢿⣿⠄⠄
